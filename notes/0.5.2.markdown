### Intent chaining

Applications that internally chain intent functions are now
recommended to use `Pass.onPass` rather than the `orElse` method
defined on `PartialFunction`.

`Pass.onPass` is aware of the explicit `Pass` object that may be
returned by intents and it is also more efficient than `orElse` for
mulptiple chained intent functions. There are two ways to use `onPass`:

    import unfiltered.request._
    val combined1 = Pass.onPass(intent1, intent2)
    val combined2 = intent1.onPass(intent2)

These two produce the same combined intent function; the second uses
an implicit conversion imported from the package object.

### unfiltered-scalatest

Corrected scala-test dependencies for different versions of Scala. {
[dwestheide][dwestheide] }

[dwestheide]: https://github.com/unfiltered/unfiltered/issues/92

### Server plan/handler methods

In recent releases these methods took a by-name parameter to support
the case where new instances of Netty handlers (the chunk aggregator
in particular) are required for each request. This lead to unexpected
behavior for some more common use cases, where the caller passed in a
`new` handler thinking it would be shared for all requests.

To avoid confusion, we've restored the previous parameter types to
`plan` and `handler` methods. If you need to pass in a plan "factory",
such as the chunk aggregator, there is a new method `makePlan` that
takes a by-name parameter.
